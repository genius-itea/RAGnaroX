Intel Itanium: Die Post-RISC-Architektur des Itanium-Designs nennt sich Explicitly Parallel Instruction Computing (EPIC) und ist eine Variante der VLIW-Architekturen. Die Besonderheit von EPIC besteht darin, dass die CPU ausgewählte Instruktionen paarweise laden und auch gleichzeitig ausführen kann – praktisch so, als ob es mehrere völlig unabhängige CPUs gäbe. Die Instruktionen passend parallel ausführbar zusammen zu bündeln ist eine nicht-triviale Aufgabe, die hier bereits der Compiler optimal lösen muss. Daher kommt dem Compiler bzw. dessen Optimierungsfähigkeiten eine besonders wichtige Bedeutung zu. Das Design verlagert also einen Teil der Komplexität weg von der CPU und hin zum Compiler. Weiter verwendet die CPU ähnlich wie RISC-Prozessoren nur eine kleine Zahl von Instruktionen, die sehr schnell ausgeführt werden können. Der Itanium verfügt wie die meisten modernen CPUs über mehrere parallele Funktionseinheiten – eine Voraussetzung für EPIC. Beim Laden und der Weitergabe der Instruktionen an die Funktionseinheiten unterscheidet sich der Itanium jedoch von der RISC-Philosophie durch den explizit parallelen Ansatz. Der Itanium geht das Problem ganz anders an, er verwendet statisches Scheduling, verlässt sich für die Sprungvorhersage also auf den Compiler. Dieser hat zwar einen vollständigeren Überblick über das Programm, jedoch nicht über die konkreten Laufzeitbedingungen (d. h. Use-cases und Parametrisierung die erst zur Laufzeit feststehen). Diese dem Compiler unbekannten Laufzeitinformation können jedoch über die Profile-Guided-Optimization-Technik über definierte Testläufe vorgegeben werden. Ergebnisse sind z. B. welche Sprünge wie oft ausgeführt werden (die GCC bietet dazu beispielsweise die Funktionen fprofile-arcs und fbranch-probabilities) und welche Funktionen Hot-Spots sind. Diese Informationen kann der Compiler verwenden, um bereits bei der Übersetzung des Programmcodes die Entscheidungen zu treffen, die sonst auf dem Chip zur Laufzeit getroffen werden müssten. Sobald dem Compiler bekannt ist, welche Pfade genommen werden, bündelt er parallel ausführbare Instruktionen zu einer größeren Instruktion. Diese lange Instruktion wird in das übersetzte Programm geschrieben. Daher der Name VLIW (Very Long Instruction Word, „sehr langes Befehlswort“).
